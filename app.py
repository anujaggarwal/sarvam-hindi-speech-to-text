#!/usr/bin/env python3
"""
Sarvam.ai Speech-to-Text Web Application
Simple web interface for Hindi speech-to-text conversion
"""

import os
import tempfile
import uuid
import time
from pathlib import Path
from flask import Flask, render_template, request, jsonify, send_file, session
from werkzeug.utils import secure_filename
import threading
from sarvam_stt import SarvamSTT
from weasyprint import HTML, CSS
from weasyprint.text.fonts import FontConfiguration
import io

app = Flask(__name__)
app.secret_key = os.urandom(24)
app.config['MAX_CONTENT_LENGTH'] = 100 * 1024 * 1024  # 100MB max file size
app.config['UPLOAD_FOLDER'] = 'temp_uploads'

# Create upload directory
os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)

# Store transcription jobs in memory (in production, use Redis or database)
transcription_jobs = {}

ALLOWED_EXTENSIONS = {'mp3', 'wav', 'm4a', 'flac'}

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def create_pdf(text, filename):
    """Create PDF from text with proper Hindi Unicode support using WeasyPrint"""
    
    # Escape HTML characters in the text
    escaped_text = text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
    
    # Create HTML content with proper Unicode support
    html_content = f"""
    <!DOCTYPE html>
    <html lang="hi">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Speech-to-Text Transcript</title>
        <style>
            @page {{
                size: A4;
                margin: 2cm;
            }}
            body {{
                font-family: 'Noto Sans Devanagari', 'Arial Unicode MS', Arial, sans-serif;
                font-size: 12pt;
                line-height: 1.6;
                color: #333;
                margin: 0;
                padding: 0;
            }}
            .header {{
                text-align: center;
                margin-bottom: 30px;
                border-bottom: 2px solid #4CAF50;
                padding-bottom: 15px;
            }}
            .title {{
                font-size: 24pt;
                font-weight: bold;
                color: #2E7D32;
                margin-bottom: 10px;
            }}
            .metadata {{
                font-size: 10pt;
                color: #666;
                margin-bottom: 20px;
                text-align: center;
            }}
            .content {{
                margin: 20px 0;
                text-align: justify;
            }}
            .transcript {{
                background-color: #f9f9f9;
                padding: 20px;
                border-left: 4px solid #4CAF50;
                border-radius: 4px;
                white-space: pre-wrap;
                word-wrap: break-word;
            }}
            .footer {{
                text-align: center;
                font-size: 9pt;
                color: #888;
                margin-top: 40px;
                border-top: 1px solid #ddd;
                padding-top: 15px;
            }}
        </style>
    </head>
    <body>
        <div class="header">
            <div class="title">Speech-to-Text Transcript</div>
        </div>
        
        <div class="metadata">
            <strong>Original File:</strong> {filename}<br>
            <strong>Generated:</strong> {time.strftime('%Y-%m-%d %H:%M:%S')}<br>
            <strong>Language:</strong> Hindi (हिन्दी)
        </div>
        
        <div class="content">
            <div class="transcript">{escaped_text}</div>
        </div>
        
        <div class="footer">
            Generated by Sarvam.ai Speech-to-Text | सर्वम.ai द्वारा निर्मित
        </div>
    </body>
    </html>
    """
    
    try:
        # Create PDF using WeasyPrint
        font_config = FontConfiguration()
        html_doc = HTML(string=html_content)
        
        # Generate PDF to BytesIO buffer
        buffer = io.BytesIO()
        html_doc.write_pdf(buffer, font_config=font_config)
        buffer.seek(0)
        
        return buffer
        
    except Exception as e:
        print(f"PDF generation error: {e}")
        # Fallback: create a simple text-based PDF
        simple_html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <style>
                body {{ font-family: Arial, sans-serif; margin: 40px; }}
                .title {{ font-size: 18pt; font-weight: bold; margin-bottom: 20px; }}
                .content {{ font-size: 12pt; line-height: 1.5; white-space: pre-wrap; }}
            </style>
        </head>
        <body>
            <div class="title">Speech-to-Text Transcript</div>
            <div class="content">{escaped_text[:2000]}{'...' if len(escaped_text) > 2000 else ''}</div>
        </body>
        </html>
        """
        
        try:
            html_doc = HTML(string=simple_html)
            buffer = io.BytesIO()
            html_doc.write_pdf(buffer)
            buffer.seek(0)
            return buffer
        except Exception as fallback_error:
            print(f"Fallback PDF generation also failed: {fallback_error}")
            # Return None to indicate PDF generation failed
            return None

def transcribe_audio_async(job_id, file_path, language_code, api_key):
    """Async transcription function"""
    try:
        transcription_jobs[job_id]['status'] = 'processing'
        transcription_jobs[job_id]['progress'] = 'Initializing transcription...'
        
        stt = SarvamSTT(api_key)
        
        # Update progress
        transcription_jobs[job_id]['progress'] = 'Analyzing audio file...'
        
        # Get audio duration
        duration = stt.get_audio_duration(file_path)
        if duration:
            transcription_jobs[job_id]['duration'] = duration
            transcription_jobs[job_id]['progress'] = f'Audio duration: {duration:.1f} seconds'
        
        # Transcribe
        if duration and duration > 30:
            transcription_jobs[job_id]['progress'] = 'Splitting large audio file...'
            chunks = stt.split_audio_ffmpeg(file_path)
            transcription_jobs[job_id]['total_chunks'] = len(chunks)
            transcription_jobs[job_id]['progress'] = f'Processing {len(chunks)} audio chunks...'
            
            # Custom transcription with progress updates
            full_transcript = []
            for idx, chunk_path in enumerate(chunks, 1):
                transcription_jobs[job_id]['progress'] = f'Processing chunk {idx}/{len(chunks)}'
                transcription_jobs[job_id]['current_chunk'] = idx
                
                transcript = stt.transcribe_chunk(chunk_path, language_code)
                if transcript:
                    full_transcript.append(transcript)
                
                # Clean up chunk
                try:
                    os.remove(chunk_path)
                except:
                    pass
            
            transcript = ' '.join(full_transcript).strip()
            
            # Clean up chunks directory
            chunks_dir = os.path.dirname(chunks[0]) if chunks else "chunks"
            try:
                os.rmdir(chunks_dir)
            except:
                pass
        else:
            transcription_jobs[job_id]['progress'] = 'Transcribing audio...'
            transcript = stt.transcribe_short_audio(file_path, language_code)
        
        if transcript:
            transcription_jobs[job_id]['status'] = 'completed'
            transcription_jobs[job_id]['transcript'] = transcript
            transcription_jobs[job_id]['progress'] = 'Transcription completed successfully!'
        else:
            transcription_jobs[job_id]['status'] = 'failed'
            transcription_jobs[job_id]['error'] = 'Transcription failed. Please check your API key and audio file.'
            
    except Exception as e:
        transcription_jobs[job_id]['status'] = 'failed'
        transcription_jobs[job_id]['error'] = str(e)
    
    finally:
        # Clean up uploaded file
        try:
            os.remove(file_path)
        except:
            pass

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/upload', methods=['POST'])
def upload_file():
    try:
        # Check if API key is provided
        api_key = request.form.get('api_key', '').strip()
        if not api_key:
            return jsonify({'error': 'API key is required'}), 400
        
        # Check if file is provided
        if 'audio_file' not in request.files:
            return jsonify({'error': 'No audio file provided'}), 400
        
        file = request.files['audio_file']
        if file.filename == '':
            return jsonify({'error': 'No file selected'}), 400
        
        if not allowed_file(file.filename):
            return jsonify({'error': 'Invalid file type. Please upload MP3, WAV, M4A, or FLAC files.'}), 400
        
        # Get language selection
        language_code = request.form.get('language', 'hi-IN')
        
        # Generate unique job ID
        job_id = str(uuid.uuid4())
        
        # Save uploaded file
        filename = secure_filename(file.filename)
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], f"{job_id}_{filename}")
        file.save(file_path)
        
        # Initialize job
        transcription_jobs[job_id] = {
            'status': 'queued',
            'progress': 'File uploaded successfully',
            'filename': filename,
            'language': language_code,
            'created_at': time.time()
        }
        
        # Start transcription in background
        thread = threading.Thread(
            target=transcribe_audio_async,
            args=(job_id, file_path, language_code, api_key)
        )
        thread.daemon = True
        thread.start()
        
        return jsonify({'job_id': job_id, 'message': 'File uploaded successfully. Transcription started.'})
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/status/<job_id>')
def get_status(job_id):
    if job_id not in transcription_jobs:
        return jsonify({'error': 'Job not found'}), 404
    
    job = transcription_jobs[job_id]
    response = {
        'status': job['status'],
        'progress': job['progress'],
        'filename': job['filename']
    }
    
    # Add additional info if available
    if 'duration' in job:
        response['duration'] = job['duration']
    if 'total_chunks' in job:
        response['total_chunks'] = job['total_chunks']
    if 'current_chunk' in job:
        response['current_chunk'] = job['current_chunk']
    if 'transcript' in job:
        response['transcript'] = job['transcript']
    if 'error' in job:
        response['error'] = job['error']
    
    return jsonify(response)

@app.route('/download/<job_id>/<format>')
def download_transcript(job_id, format):
    if job_id not in transcription_jobs:
        return jsonify({'error': 'Job not found'}), 404
    
    job = transcription_jobs[job_id]
    if job['status'] != 'completed' or 'transcript' not in job:
        return jsonify({'error': 'Transcript not ready'}), 400
    
    transcript = job['transcript']
    filename = job['filename']
    base_name = os.path.splitext(filename)[0]
    
    if format == 'txt':
        # Create text file
        output = io.StringIO()
        output.write(f"Speech-to-Text Transcript\n")
        output.write(f"Original File: {filename}\n")
        output.write(f"Language: {job['language']}\n")
        output.write(f"Generated: {time.strftime('%Y-%m-%d %H:%M:%S')}\n")
        output.write("-" * 50 + "\n\n")
        output.write(transcript)
        
        # Convert to bytes
        output_bytes = io.BytesIO()
        output_bytes.write(output.getvalue().encode('utf-8'))
        output_bytes.seek(0)
        
        return send_file(
            output_bytes,
            as_attachment=True,
            download_name=f"{base_name}_transcript.txt",
            mimetype='text/plain'
        )
    
    elif format == 'pdf':
        # Create PDF
        pdf_buffer = create_pdf(transcript, filename)
        
        if pdf_buffer is None:
            return jsonify({'error': 'PDF generation failed. Please try downloading as TXT format.'}), 500
        
        return send_file(
            pdf_buffer,
            as_attachment=True,
            download_name=f"{base_name}_transcript.pdf",
            mimetype='application/pdf'
        )
    
    else:
        return jsonify({'error': 'Invalid format'}), 400

@app.route('/cleanup')
def cleanup_old_jobs():
    """Clean up old jobs (older than 1 hour)"""
    current_time = time.time()
    old_jobs = []
    
    for job_id, job in transcription_jobs.items():
        if current_time - job.get('created_at', 0) > 3600:  # 1 hour
            old_jobs.append(job_id)
    
    for job_id in old_jobs:
        del transcription_jobs[job_id]
    
    return jsonify({'cleaned': len(old_jobs)})

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5002)
